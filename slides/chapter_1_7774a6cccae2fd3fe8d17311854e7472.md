---
title: Insert title here
key: 7774a6cccae2fd3fe8d17311854e7472

---
## Screencast

```yaml
type: "TitleSlide"
key: "be5c7a4595"
```

`@lower_third`

name: Christopher Bruffaerts
title: Lecturer in Data science, EPFL


`@script`
In this lesson, we are going to cover the so-called Apriori algorithm. On the one hand we are going to understand the rationale behind this algorithm and on the other hand see how to apply it with the arules package. 
To do so, we are going to make use of concepts seen in the previous lessons such as transactional data and the corresponding metrics.


---
## Transactional data from the supermarket

```yaml
type: "TwoColumns"
key: "4e02bdb379"
code_zoom: 100
```

`@part1`
**List of items**

| Items  | Abbreviation
|--------|----------|
| Bread  | BR		|
| Butter | BT		|
| Cheese | CH		|
| Wine   | WN		|


`@part2`
| TID 	 | Transaction                            |
|--------|----------------------------------------|
| 1      | {BR, BT, CH, WN}     	  |
| 2      | {BR, BT, WN}              |
| 3      | {BR, BT}                |
| 4      | {BT, CH, WN}         |
| 5      | {BT, CH}         |
| 6      | {CH, WN}         |
| 7      | {BT, WN}         |


`@script`
Recall from previous chapters that we are using the supermarket data as illustrative example. Suppose there are 4 items we are interested in: Bread, Butter, Cheese and Wine. To make it easier for the rest of the lesson, let us use the following abbreviations.

Assume that you are given a set of 7 transactions, all having a specific ID. For instance, the first transaction/basket includes all 4 items, while the last one only includes butter and wine.


---
## Idea behind the Apriori algorithm

```yaml
type: "FullSlide"
key: "0a6b566e2c"
```

`@part1`
**Remember**: Each transaction is seen as a set of items.

Goal of the apriori algorithm is twofold:

- **Frequent itemset generation**: determine all frequent itemsets of a potentially large database of transactions. An itemset is said to be frequent if it satisfies a _minimum support threshold_.

- **Rule generation**: extract all the high-confidence rules from the frequent itemsets found in the previous steps.


Apriori algorithm allows to discover interesting relationships between items in a large transactional database.{{2}}


`@script`
Extract some induced rules from the itemsets, known as _association rule learning_ over transactional database

The computational requirements for frequent itemset generation are more expensive than those of rule generation.


---
## Test image

```yaml
type: "FullSlide"
key: "81b3785def"
```

`@part1`
![blbalb](https://assets.datacamp.com/production/repositories/4926/datasets/a9557d9866060fbab757d1ecc1c476622ae5dc6a/basket.jpg = 20){{1}}

![test2](https://assets.datacamp.com/production/repositories/4926/datasets/a9557d9866060fbab757d1ecc1c476622ae5dc6a/basket.jpg = 20){{2}}


`@script`



---
## Back to the supermarket example (1)

```yaml
type: "TwoColumns"
key: "f2c69e3c41"
```

`@part1`
| TID 	 | Transaction                            |
|--------|----------------------------------------|
| 1      | {BR, BT, CH, WN}     	  |
| 2      | {BR, BT, WN}              |
| 3      | {BR, BT}                |
| 4      | {BT, CH, WN}         |
| 5      | {BT, CH}         |
| 6      | {CH, WN}         |
| 7      | {BT, WN}         |


`@part2`
- Count number of 1-itemset
	- {BR} : 3
	- {BT} : 6
    - {CH} : 4
    - {WN} : 5

- Count number of 2-itemsets
	- {BT, WN} : 4
    - {BR, BT}, {BT, CH}, {BR, BT} : 3
    - {BR, WN} : 2
    - {BR, CH} : 1


`@script`



---
## Back to the supermarket example (2)

```yaml
type: "TwoColumns"
key: "77e0582f88"
```

`@part1`
| TID 	 | Transaction                            |
|--------|----------------------------------------|
| 1      | {BR, BT, CH, WN}     	  |
| 2      | {BR, BT, WN}              |
| 3      | {BR, BT}                |
| 4      | {BT, CH, WN}         |
| 5      | {BT, CH}         |
| 6      | {CH, WN}         |
| 7      | {BT, WN}         |


`@part2`
- Count number of 3-itemset
	- {BT, CH, WN} : 2
	- {BR, BT, CH} : 1
    - {BR; BT, WN} : 1
    - {BR, CH, WN} : 1

- Count number of 4-itemsets
	- {BR, BT, CH, WN} : 1

(show itemset lattice)


`@script`



---
## Backbone of Apriori algorithm

```yaml
type: "FullSlide"
key: "a9578f79ad"
```

`@part1`
Idea/rationale

- Bottom-up approach
- Level-wise, breath-first algorithm which counts transactions


`@script`



---
## Getting to know the apriori function

```yaml
type: "FullSlide"
key: "a6ae55fdc5"
```

`@part1`
Transactional data
```
trans <- as(data_list, "transactions")
inspect(trans)
```

# Apriori function

```
?apriori
# Launch apriori algorithm
apriori_rules <- apriori(trans,
                         parameter = list(support = 0.01,
                                          confidence = 0.5))
```


`@script`
We first use a standard call to the apriori function with default parameters


---
## Apriori output

```yaml
type: "FullSlide"
key: "6dfbd04c01"
```

`@part1`
show output of apriori

```

```


`@script`



---
## Apriori - rule extraction

```yaml
type: "FullSlide"
key: "7acad20eeb"
```

`@part1`
```
summary(apriori_rules)
```

```
# Inspect rules - sort by confidence
inspect(sort(apriori_rules, by="confidence"))
inspect(head(sort(apriori_rules, by = "confidence"), 3))
```

```
# Sorting rules
rules_conf <- sort (apriori_rules, by="confidence", decreasing=TRUE)
rules_lift <- sort (apriori_rules, by="lift", decreasing=TRUE)
inspect(head(rules_lift)) 
```


`@script`



---
## Rule redundancy

```yaml
type: "FullSlide"
key: "2686cd1e37"
```

`@part1`
```
subsetRules <- which(colSums(is.subset(apriori_rules, apriori_rules)) > 1) 
length(subsetRules)  
apriori_rules2 <- apriori_rules[-subsetRules]  
inspect(apriori_rules2)
summary(apriori_rules2)
```


`@script`



---
## Specific rules

```yaml
type: "FullSlide"
key: "753b30f2db"
```

`@part1`
Rules for specific items

```
bread_rules <- apriori(data=trans, 
					   parameter=list(supp=0.001,conf = 0.08), 						   appearance = list(rhs="Bread"))
                       
inspect(bread_rules)

bread_rules2 <- apriori (data=trans, parameter=list (supp=0.001,conf = 0.08), appearance = list (default="lhs",rhs="Bread"), control = list (verbose=F)) 
summary(bread_rules2)

```


`@script`



---
## Parameters and controls of the apriori

```yaml
type: "FullSlide"
key: "0472819503"
```

`@part1`
- **Parameter**: the mining parameters change the characteristics of the mined itemsets or rules (e.g. minimum support)
- **Control**: influence the performance of the algorithm (e.g. ???)


```
?apriori
?APparameter
?APcontrol
?APcontrolappearance
```


`@script`



---
## Apriori options

```yaml
type: "FullSlide"
key: "c76f2b1c05"
```

`@part1`
List all possible options available in arules with apriori

```
summary()
length()
items()
write()
write.pmml()
```


`@script`



---
## Let's practice!

```yaml
type: "FinalSlide"
key: "cbc4d2b5e4"
```

`@script`
Now it is your turn to practice the skills you have learned on the Online Retail dataset. Happy shopping!

