---
title: Insert title here
key: 7774a6cccae2fd3fe8d17311854e7472

---
## Screencast

```yaml
type: "TitleSlide"
key: "be5c7a4595"
```

`@lower_third`

name: Christopher Bruffaerts
title: Lecturer in Data science, EPFL


`@script`
In this lesson, we are going to cover the so-called Apriori algorithm. On the one hand we are going to understand the rationale behind this algorithm and on the other hand see how to apply it with the arules package. 
To do so, we are going to make use of concepts seen in the previous lessons such as transactional data and the corresponding metrics.


---
## Association rule mining

```yaml
type: "FullSlide"
key: "c825ec5187"
```

`@part1`
**Association rule mining** allows to discover interesting relationships between items in a large transactional database.

This mining task can be divided into two subtasks:

- **Frequent itemset generation**: determine all frequent itemsets of a potentially large database of transactions. An itemset is said to be frequent if it satisfies a _minimum support threshold_.

- **Rule generation**: extract all the high-confidence rules from the frequent itemsets found in the previous steps.


Apriori is one algorithm belonging to the category of association rule mining.


`@script`
Extract some induced rules from the itemsets, known as _association rule learning_ over transactional database

The computational requirements for frequent itemset generation are more expensive than those of rule generation.


---
## Back to the transactional data

```yaml
type: "TwoColumns"
key: "1813478938"
hide_title: false
```

`@part1`
| TID 	 | Transaction                            |
|--------|----------------------------------------|
| 1      | {A, B, C, D}     	  |
| 2      | {A, B, D}              |
| 3      | {A, B}                |
| 4      | {B, C, D}         |
| 5      | {B, C}         |
| 6      | {C, D}         |
| 7      | {B, D}         |


`@part2`
![itemset_lattice](https://assets.datacamp.com/production/repositories/4926/datasets/d7997ea66cddc7c86cc7a84319b8cc640a6a4643/itemset_lattice.png =110){{2}}


`@script`
Recall from the previous chapters that we are working with a transactional dataset with 4 items, denoted as A, B, C and D to keep it easy. You can for instance imagine that these items represent items such as Bread, Butter, Cheese and Wine.

Remember that you are given a set of 7 transactions, all having a specific ID, the transaction ID. As you can see, the first transaction/basket includes all 4 items, while the last one only includes items B and D.


We are going to use the itemset lattice we have seen previously to illustrate how the association rule mining works, and in particular how the apriori algorithm functions. The itemset lattice displays all possible subsets of the original set of 4 items, organized as levels (starting from the empty set, 1-itemset, 2-itemsets, 3-itemsets and the 4-itemset).


---
## Idea behind the Apriori algorithm

```yaml
type: "FullSlide"
key: "0a6b566e2c"
```

`@part1`
Add the different steps


`@script`



---
## Apriori principle

```yaml
type: "FullSlide"
key: "a9578f79ad"
```

`@part1`
Idea/rationale

- Bottom-up approach
- Level-wise, breath-first algorithm which counts transactions


**Apriori principle**: If an itemset is frequent, then all of its subsets must also be frequent.


`@script`



---
## Example: 1-itemset

```yaml
type: "TwoColumns"
key: "867fc1190a"
```

`@part1`
![item_set_lattice2](https://assets.datacamp.com/production/repositories/4926/datasets/2410e69c0cc858c2d970f83b1d36b98daf3f7b6e/itemset_lattice_1_r.png =82)


`@part2`
| TID 	 | Transaction                            |
|--------|----------------------------------------|
| 1      | {A, B, C, D}     	  |
| 2      | {A, B, D}              |
| 3      | {A, B}                |
| 4      | {B, C, D}         |
| 5      | {B, C}         |
| 6      | {C, D}         |
| 7      | {B, D}         |


`@script`



---
## Example: 2-itemsets

```yaml
type: "TwoColumns"
key: "0d9dabb41c"
```

`@part1`
![item_set_lattice3](https://assets.datacamp.com/production/repositories/4926/datasets/c47cab96e3fe4710525fcece8c9299b86feb52b7/itemset_lattice_2_r.png =82)


`@part2`
| TID 	 | Transaction                            |
|--------|----------------------------------------|
| 1      | {A, B, C, D}     	  |
| 2      | {A, B, D}              |
| 3      | {A, B}                |
| 4      | {B, C, D}         |
| 5      | {B, C}         |
| 6      | {C, D}         |
| 7      | {B, D}         |


`@script`



---
## Getting to know the apriori function

```yaml
type: "FullSlide"
key: "a6ae55fdc5"
```

`@part1`
**Transactional data**
```
trans <- as(data_list, "transactions")
inspect(trans)
```

# Apriori function

```
?apriori
# Launch apriori algorithm
apriori_rules <- apriori(trans,
                         parameter = list(support = 0.01,
                                          confidence = 0.5))
```


`@script`
We first use a standard call to the apriori function with default parameters


---
## Apriori output

```yaml
type: "FullSlide"
key: "6dfbd04c01"
```

`@part1`
show output of apriori

```

```


`@script`



---
## Apriori - rule extraction

```yaml
type: "FullSlide"
key: "7acad20eeb"
```

`@part1`
```
summary(apriori_rules)
```

```
# Inspect rules - sort by confidence
inspect(sort(apriori_rules, by="confidence"))
inspect(head(sort(apriori_rules, by = "confidence"), 3))
```

```
# Sorting rules
rules_conf <- sort (apriori_rules, by="confidence", decreasing=TRUE)
rules_lift <- sort (apriori_rules, by="lift", decreasing=TRUE)
inspect(head(rules_lift)) 
```


`@script`



---
## Rule redundancy

```yaml
type: "FullSlide"
key: "2686cd1e37"
```

`@part1`
What is a redundant rule?


How redundant is the set of extracted rules?

```
subsetRules <- which(colSums(is.subset(apriori_rules, apriori_rules)) > 1) 
length(subsetRules)  
apriori_rules2 <- apriori_rules[-subsetRules]  
inspect(apriori_rules2)
summary(apriori_rules2)
```


`@script`
Given the large number of rules extracted from the apriori function, it is necessary to get an overview of redundant rules. What do we mean by "redundant" rule?


---
## Specific rules

```yaml
type: "FullSlide"
key: "753b30f2db"
```

`@part1`
Rules for specific items

```
bread_rules <- apriori(data=trans, 
					   parameter=list(supp=0.001,conf = 0.08), 						   appearance = list(rhs="Bread"))
                       
inspect(bread_rules)

bread_rules2 <- apriori (data=trans, parameter=list (supp=0.001,conf = 0.08), appearance = list (default="lhs",rhs="Bread"), control = list (verbose=F)) 
summary(bread_rules2)

```


`@script`



---
## Parameters and controls of the apriori

```yaml
type: "FullSlide"
key: "0472819503"
```

`@part1`
- **Parameter**: the mining parameters change the characteristics of the mined itemsets or rules (e.g. minimum support)
- **Control**: influence the performance of the algorithm (e.g. ???)


```
?apriori
?APparameter
?APcontrol
?APcontrolappearance
```


`@script`



---
## Apriori options

```yaml
type: "FullSlide"
key: "c76f2b1c05"
```

`@part1`
List all possible options available in arules with apriori

```
summary()
length()
items()
write()
write.pmml()
```


`@script`



---
## Let's practice!

```yaml
type: "FinalSlide"
key: "cbc4d2b5e4"
```

`@script`
Now it is your turn to practice the skills you have learned on the Online Retail dataset. Happy shopping!

