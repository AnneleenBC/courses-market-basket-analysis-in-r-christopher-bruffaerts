---
title: Insert title here
key: 7774a6cccae2fd3fe8d17311854e7472

---
## Screencast

```yaml
type: "TitleSlide"
key: "be5c7a4595"
```

`@lower_third`

name: Christopher Bruffaerts
title: Lecturer in Data science, EPFL


`@script`
In this lesson, we are going to cover one of the algorithm behind the association rule mining, the so-called apriori algorithm. We are first going to understand the rationale behind this algorithm and afterwards see how to apply it with the arules package.


---
## Association rule mining

```yaml
type: "FullSlide"
key: "c825ec5187"
```

`@part1`
**Association rule mining** allows to discover interesting relationships between items in a large transactional database.

This mining task can be divided into two subtasks:

- **Frequent itemset generation**: determine all frequent itemsets of a potentially large database of transactions. An itemset is said to be frequent if it satisfies a _minimum support threshold_.

- **Rule generation**: extract all the high-confidence rules from the frequent itemsets found in the previous steps.

&nbsp;

The **Apriori algorithm** is one of the algorithm belonging to the category of association rule mining.


`@script`
The main purpose of the association rule mining is to extract some induced rules from the itemsets over a transactional database. This _association rule learning_ allows to discover ....

To reach this goal, the mining process can be decomposed into two subtasks. First, the set of frequent items has to be generated from the database of transactions. An itemset is considered as frequent if its support satisfies a minimum threshold value. 
Second, using the frequent itemsets, the set of high confidence rules is extracted.

The computational requirements for frequent itemset generation are more expensive than those of rule generation.


---
## Back to the transactional data

```yaml
type: "TwoColumns"
key: "1813478938"
hide_title: false
```

`@part1`
| TID 	 | Transaction                            |
|--------|----------------------------------------|
| 1      | {A, B, C, D}     	  |
| 2      | {A, B, D}              |
| 3      | {A, B}                |
| 4      | {B, C, D}         |
| 5      | {B, C}         |
| 6      | {C, D}         |
| 7      | {B, D}         |


`@part2`
![itemset_lattice](https://assets.datacamp.com/production/repositories/4926/datasets/d7997ea66cddc7c86cc7a84319b8cc640a6a4643/itemset_lattice.png =110){{2}}


`@script`
Recall from the previous chapters that we are working with a transactional dataset with 4 items, denoted as A, B, C and D to keep it easy. You can for instance imagine that these items represent items such as Bread, Butter, Cheese and Wine.

Remember that you are given a set of 7 transactions, all having a specific ID, the transaction ID. As you can see, the first transaction/basket includes all 4 items, while the last one only includes items B and D.


We are going to use the itemset lattice we have seen previously to illustrate how the association rule mining works, and in particular how the apriori algorithm functions. The itemset lattice displays all possible subsets of the original set of 4 items, organized as levels (starting from the empty set, 1-itemset, 2-itemsets, 3-itemsets and the 4-itemset).


---
## Idea behind the Apriori algorithm

```yaml
type: "FullSlide"
key: "0a6b566e2c"
```

`@part1`
Add the different steps


`@script`



---
## Apriori principle

```yaml
type: "FullSlide"
key: "a9578f79ad"
```

`@part1`
Idea/rationale

- Bottom-up approach
- Level-wise, breath-first algorithm which counts transactions


**Apriori principle**:

If an itemset is frequent, then all of its subsets must also be frequent.

Anti-monotonicity


`@script`



---
## Example: 1-itemset

```yaml
type: "TwoColumns"
key: "867fc1190a"
```

`@part1`
![item_set_lattice2](https://assets.datacamp.com/production/repositories/4926/datasets/2410e69c0cc858c2d970f83b1d36b98daf3f7b6e/itemset_lattice_1_r.png =82)


`@part2`
| TID 	 | Transaction                            |
|--------|----------------------------------------|
| 1      | {A, B, C, D}     	  |
| 2      | {A, B, D}              |
| 3      | {A, B}                |
| 4      | {B, C, D}         |
| 5      | {B, C}         |
| 6      | {C, D}         |
| 7      | {B, D}         |


`@script`



---
## Example: 2-itemsets

```yaml
type: "TwoColumns"
key: "0d9dabb41c"
```

`@part1`
![item_set_lattice3](https://assets.datacamp.com/production/repositories/4926/datasets/c47cab96e3fe4710525fcece8c9299b86feb52b7/itemset_lattice_2_r.png =82)


`@part2`
| TID 	 | Transaction                            |
|--------|----------------------------------------|
| 1      | {A, B, C, D}     	  |
| 2      | {A, B, D}              |
| 3      | {A, B}                |
| 4      | {B, C, D}         |
| 5      | {B, C}         |
| 6      | {C, D}         |
| 7      | {B, D}         |


`@script`



---
## Example: 3-itemsets & pruning

```yaml
type: "TwoColumns"
key: "bc082b2107"
```

`@part1`
![item_set_lattice3](https://assets.datacamp.com/production/repositories/4926/datasets/d5b118db4742b74701f5e8f9371e86b485fb7fff/itemset_lattice_3_r.png =82)


`@part2`
| TID 	 | Transaction                            |
|--------|----------------------------------------|
| 1      | {A, B, C, D}     	  |
| 2      | {A, B, D}              |
| 3      | {A, B}                |
| 4      | {B, C, D}         |
| 5      | {B, C}         |
| 6      | {C, D}         |
| 7      | {B, D}         |


`@script`



---
## Getting to know the apriori function

```yaml
type: "FullSlide"
key: "a6ae55fdc5"
```

`@part1`
**Transactional data**
```
trans <- as(data_list, "transactions")
```

**Apriori function**
```
?apriori
```

**First call to the apriori function - frequent itemsets**
```r
support.all = apriori(trans, parameter = list(target="frequent itemsets"))
inspect(support.all)
```


`@script`
Remember that the data we are working with is a transactional type of dataset, or one that can be coerced to such type.

It is always a good practice to check the documentation of a R function before working with it. 

Let us start with a standard call of the apriori function with default parameters. Afterwards, we will play with the various parameters of the function. 
In this first call of the function, we retrieve the list of frequent itemsets.


---
## First output of apriori

```yaml
type: "FullSlide"
key: "afe50c4b82"
```

`@part1`



`@script`



---
## Getting to know the apriori function 2

```yaml
type: "FullSlide"
key: "300fe878ef"
```

`@part1`
**First call to the apriori function - rule generation**
```
rules.all = apriori(trans)
inspect(rules.all)
```


`@script`



---
## Apriori output

```yaml
type: "FullSlide"
key: "7acad20eeb"
```

`@part1`
**Summary of rules** 
```
summary(apriori_rules)
```

**Sorting rules**
```
# Inspect rules - sort by confidence
rules.sorted = sort(rules, by = "support")
inspect(rules.sorted)
# Sorting rules
rules_conf <- sort (apriori_rules, by="confidence", decreasing=TRUE)
rules_lift <- sort (apriori_rules, by="lift", decreasing=TRUE)
inspect(head(rules_lift)) 

```


`@script`



---
## Parameters and controls of the apriori

```yaml
type: "FullSlide"
key: "0472819503"
```

`@part1`
- **Parameter**: the mining parameters change the characteristics of the mined itemsets or rules (e.g. minimum support)
- **Control**: influence the performance of the algorithm (e.g. ???)


```
?apriori
?APparameter
?APcontrol
?APcontrolappearance
```


`@script`



---
## Rule redundancy

```yaml
type: "FullSlide"
key: "2686cd1e37"
```

`@part1`
What is a redundant rule?


How redundant is the set of extracted rules?

```
subsetRules <- which(colSums(is.subset(apriori_rules, apriori_rules)) > 1) 
length(subsetRules)  
apriori_rules2 <- apriori_rules[-subsetRules]  
inspect(apriori_rules2)
summary(apriori_rules2)
```


`@script`
Given the large number of rules extracted from the apriori function, it is necessary to get an overview of redundant rules. What do we mean by "redundant" rule?


---
## Rule redundancy

```yaml
type: "FullSlide"
key: "b4a3bac3eb"
```

`@part1`
show example of redundant rule


`@script`



---
## Specific rules

```yaml
type: "FullSlide"
key: "753b30f2db"
```

`@part1`
Rules for specific items

```
bread_rules <- apriori(data=trans, 
					   parameter=list(supp=0.001,conf = 0.08), 						   appearance = list(rhs="Bread"))
                       
inspect(bread_rules)

bread_rules2 <- apriori (data=trans, parameter=list (supp=0.001,conf = 0.08), appearance = list (default="lhs",rhs="Bread"), control = list (verbose=F)) 
summary(bread_rules2)

```


`@script`



---
## Apriori options

```yaml
type: "FullSlide"
key: "c76f2b1c05"
```

`@part1`
List all possible options available in arules with apriori

```
summary()
length()
items()
write()
write.pmml()
```


`@script`



---
## Let's practice!

```yaml
type: "FinalSlide"
key: "cbc4d2b5e4"
```

`@script`
Now it is your turn to practice the skills you have learned on the Online Retail dataset. Happy shopping!

