---
title: Insert title here
key: 7774a6cccae2fd3fe8d17311854e7472

---
## Screencast

```yaml
type: "TitleSlide"
key: "be5c7a4595"
```

`@lower_third`

name: Christopher Bruffaerts
title: Lecturer in Data science, EPFL


`@script`
In this lesson, we are going to cover the so-called Apriori algorithm. On the one hand we are going to understand the rationale behind this algorithm and on the other hand see how to apply it with the arules package. 
To do so, we are going to make use of concepts seen in the previous lessons such as transactional data and the corresponding metrics.


---
## Transactional data from the supermarket

```yaml
type: "TwoColumns"
key: "4e02bdb379"
code_zoom: 100
```

`@part1`
**List of 4 items**

| Items  | 
|--------|
| A  | 
| B |
| C | 
| D   |


`@part2`
| TID 	 | Transaction                            |
|--------|----------------------------------------|
| 1      | {A, B, C, D}     	  |
| 2      | {A, B, D}              |
| 3      | {A, B}                |
| 4      | {B, C, D}         |
| 5      | {B, C}         |
| 6      | {C, D}         |
| 7      | {B, D}         |


`@script`
Recall from the previous chapters that we are working with the supermarket data for illustration purposes. Suppose there are 4 items we are interested in which are denoted as A, B, C and D to keep it easy. You can for instance imagine that these items represent items such as Bread, Butter, Cheese and Wine.

Assume that you are given a set of 7 transactions, all having a specific ID, the transaction ID. As you can see, the first transaction/basket includes all 4 items, while the last one only includes items B and D.


---
## Idea behind the Apriori algorithm

```yaml
type: "FullSlide"
key: "0a6b566e2c"
```

`@part1`
**Remember**: Each transaction is seen as a set of items.

Apriori algorithm allows to discover interesting relationships between items in a large transactional database.

The apriori algorithm is divided into two subtasks:{{2}}

- **Frequent itemset generation**: determine all frequent itemsets of a potentially large database of transactions. An itemset is said to be frequent if it satisfies a _minimum support threshold_.{{2}}

- **Rule generation**: extract all the high-confidence rules from the frequent itemsets found in the previous steps.{{2}}


`@script`
Extract some induced rules from the itemsets, known as _association rule learning_ over transactional database

The computational requirements for frequent itemset generation are more expensive than those of rule generation.


---
## Back to the supermarket example (1)

```yaml
type: "TwoColumns"
key: "f2c69e3c41"
```

`@part1`
| TID 	 | Transaction                            |
|--------|----------------------------------------|
| 1      | {BR, BT, CH, WN}     	  |
| 2      | {BR, BT, WN}              |
| 3      | {BR, BT}                |
| 4      | {BT, CH, WN}         |
| 5      | {BT, CH}         |
| 6      | {CH, WN}         |
| 7      | {BT, WN}         |


`@part2`
- Count number of 1-itemset
	- {BR} : 3
	- {BT} : 6
    - {CH} : 4
    - {WN} : 5

- Count number of 2-itemsets
	- {BT, WN} : 4
    - {BR, BT}, {BT, CH}, {BR, BT} : 3
    - {BR, WN} : 2
    - {BR, CH} : 1


`@script`
Given the set of 7 transactions, we start by counting the number of items


---
## Back to the supermarket example (2)

```yaml
type: "TwoColumns"
key: "77e0582f88"
```

`@part1`
| TID 	 | Transaction                            |
|--------|----------------------------------------|
| 1      | {BR, BT, CH, WN}     	  |
| 2      | {BR, BT, WN}              |
| 3      | {BR, BT}                |
| 4      | {BT, CH, WN}         |
| 5      | {BT, CH}         |
| 6      | {CH, WN}         |
| 7      | {BT, WN}         |


`@part2`
- Count number of 3-itemset
	- {BT, CH, WN} : 2
	- {BR, BT, CH} : 1
    - {BR; BT, WN} : 1
    - {BR, CH, WN} : 1

- Count number of 4-itemsets
	- {BR, BT, CH, WN} : 1

(show itemset lattice)


`@script`



---
## Apriori principle

```yaml
type: "FullSlide"
key: "a9578f79ad"
```

`@part1`
Idea/rationale

- Bottom-up approach
- Level-wise, breath-first algorithm which counts transactions


**Apriori principle**: If an itemset is frequent, then all of its subsets must also be frequent.


`@script`



---
## Illustration of the apriori principle

```yaml
type: "FullSlide"
key: "4514115004"
```

`@part1`
Show example with itemset lattice


`@script`



---
## Getting to know the apriori function

```yaml
type: "FullSlide"
key: "a6ae55fdc5"
```

`@part1`
**Transactional data**
```
trans <- as(data_list, "transactions")
inspect(trans)
```

# Apriori function

```
?apriori
# Launch apriori algorithm
apriori_rules <- apriori(trans,
                         parameter = list(support = 0.01,
                                          confidence = 0.5))
```


`@script`
We first use a standard call to the apriori function with default parameters


---
## Apriori output

```yaml
type: "FullSlide"
key: "6dfbd04c01"
```

`@part1`
show output of apriori

```

```


`@script`



---
## Apriori - rule extraction

```yaml
type: "FullSlide"
key: "7acad20eeb"
```

`@part1`
```
summary(apriori_rules)
```

```
# Inspect rules - sort by confidence
inspect(sort(apriori_rules, by="confidence"))
inspect(head(sort(apriori_rules, by = "confidence"), 3))
```

```
# Sorting rules
rules_conf <- sort (apriori_rules, by="confidence", decreasing=TRUE)
rules_lift <- sort (apriori_rules, by="lift", decreasing=TRUE)
inspect(head(rules_lift)) 
```


`@script`



---
## Rule redundancy

```yaml
type: "FullSlide"
key: "2686cd1e37"
```

`@part1`
What is a redundant rule?


How redundant is the set of extracted rules?

```
subsetRules <- which(colSums(is.subset(apriori_rules, apriori_rules)) > 1) 
length(subsetRules)  
apriori_rules2 <- apriori_rules[-subsetRules]  
inspect(apriori_rules2)
summary(apriori_rules2)
```


`@script`
Given the large number of rules extracted from the apriori function, it is necessary to get an overview of redundant rules. What do we mean by "redundant" rule?


---
## Specific rules

```yaml
type: "FullSlide"
key: "753b30f2db"
```

`@part1`
Rules for specific items

```
bread_rules <- apriori(data=trans, 
					   parameter=list(supp=0.001,conf = 0.08), 						   appearance = list(rhs="Bread"))
                       
inspect(bread_rules)

bread_rules2 <- apriori (data=trans, parameter=list (supp=0.001,conf = 0.08), appearance = list (default="lhs",rhs="Bread"), control = list (verbose=F)) 
summary(bread_rules2)

```


`@script`



---
## Parameters and controls of the apriori

```yaml
type: "FullSlide"
key: "0472819503"
```

`@part1`
- **Parameter**: the mining parameters change the characteristics of the mined itemsets or rules (e.g. minimum support)
- **Control**: influence the performance of the algorithm (e.g. ???)


```
?apriori
?APparameter
?APcontrol
?APcontrolappearance
```


`@script`



---
## Apriori options

```yaml
type: "FullSlide"
key: "c76f2b1c05"
```

`@part1`
List all possible options available in arules with apriori

```
summary()
length()
items()
write()
write.pmml()
```


`@script`



---
## Test image

```yaml
type: "FullSlide"
key: "81b3785def"
```

`@part1`
![blbalb](https://assets.datacamp.com/production/repositories/4926/datasets/a9557d9866060fbab757d1ecc1c476622ae5dc6a/basket.jpg = 20){{1}}

![test2](https://assets.datacamp.com/production/repositories/4926/datasets/a9557d9866060fbab757d1ecc1c476622ae5dc6a/basket.jpg = 20){{2}}


`@script`



---
## Let's practice!

```yaml
type: "FinalSlide"
key: "cbc4d2b5e4"
```

`@script`
Now it is your turn to practice the skills you have learned on the Online Retail dataset. Happy shopping!

